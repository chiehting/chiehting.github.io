<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>devops on Chiehting</title><link>https://chiehting.com/category/devops/</link><description>Recent content in devops on Chiehting</description><generator>Hugo -- gohugo.io</generator><copyright>Copyright © 2008–2018, Steve Francia and the Hugo Authors; all rights reserved.</copyright><lastBuildDate>Thu, 24 Oct 2024 12:25:08 +0800</lastBuildDate><atom:link href="https://chiehting.com/category/devops/index.xml" rel="self" type="application/rss+xml"/><item><title>uber/kraken container registry</title><link>https://chiehting.com/posts/kraken-container-registry/</link><pubDate>Thu, 24 Oct 2024 12:25:08 +0800</pubDate><guid>https://chiehting.com/posts/kraken-container-registry/</guid><description>
&lt;p>Kraken 是一個使用 P2P 技術的容器映像檔推拉服務，適合在分散式架構下使用。官方測試 Kraken distributes 20K 100MB-1G blobs in under 30 sec。&lt;/p>
&lt;h3 id="refencers">Refencers&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="https://github.com/uber/kraken">Github&lt;/a>&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>Kraken has been in production at Uber since early 2018. In our busiest cluster, Kraken distributes more than 1 million blobs per day, including 100k 1G+ blobs. At its peak production load, Kraken distributes 20K 100MB-1G blobs in under 30 sec.&lt;/p>
&lt;/blockquote>
&lt;h3 id="使用情境">使用情境&lt;/h3>
&lt;p>要在跨雲環境中使用Kraken，我們需要考慮幾個關鍵點：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>網絡連接：&lt;/p>
&lt;ul>
&lt;li>確保不同雲環境之間有穩定的網絡連接。這可能需要設置VPN或直接連接服務（如AWS Direct Connect或Azure ExpressRoute）。&lt;/li>
&lt;li>配置防火牆規則，允許Kraken組件之間的通信。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>中央協調：&lt;/p>
&lt;ul>
&lt;li>在一個中心位置部署Tracker組件。這可以是任何一個雲環境，或者是一個中立的位置。&lt;/li>
&lt;li>Tracker需要能夠與所有雲環境中的Agent和Origin通信。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>存儲配置：&lt;/p>
&lt;ul>
&lt;li>利用Kraken的可插拔存儲特性。在每個雲環境中配置適當的存儲後端（例如，在AWS中使用S3，在Azure中使用Blob Storage）。&lt;/li>
&lt;li>確保Origin組件可以訪問這些存儲後端。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Agent部署：&lt;/p>
&lt;ul>
&lt;li>在每個雲環境的所有主機上部署Agent。&lt;/li>
&lt;li>配置Agent使其能夠與中央Tracker通信。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>跨雲複製：&lt;/p>
&lt;ul>
&lt;li>利用Kraken的跨集群複製功能。設置規則，以確保重要的映像在不同的雲環境之間同步。&lt;/li>
&lt;li>這可以通過Build-Index組件來管理。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>負載均衡：&lt;/p>
&lt;ul>
&lt;li>在每個雲環境中部署Proxy組件。&lt;/li>
&lt;li>使用雲提供商的負載均衡服務來分配對Proxy的請求。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>DNS配置：&lt;/p>
&lt;ul>
&lt;li>設置DNS以便各個組件可以相互發現。這可能需要使用跨雲DNS解決方案。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>監控和日誌：&lt;/p>
&lt;ul>
&lt;li>實施跨雲監控解決方案，以便您可以監視所有環境中的Kraken性能。&lt;/li>
&lt;li>集中日誌收集，以便於故障排除。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>安全性：&lt;/p>
&lt;ul>
&lt;li>實施端到端加密，特別是對於跨雲通信。&lt;/li>
&lt;li>使用雲提供商的身份和訪問管理服務來控制對Kraken組件的訪問。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>災難恢復：&lt;/p>
&lt;ul>
&lt;li>在不同的雲環境中設置備份和故障轉移機制。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="devcluster">devcluster&lt;/h3>
&lt;p>在專案下有提供測試使用的環境 devcluster，可以執行命令啟動服務。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">make images &lt;span class="c1"># 編譯所有組建映像檔&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">make devcluster &lt;span class="c1"># 本地運行測試&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在容器內 agent 的執行命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">&lt;span class="c1"># kraken-agent-one&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">2&lt;/span>&lt;span class="cl">/usr/bin/kraken-agent --config&lt;span class="o">=&lt;/span>/etc/kraken/config/agent/development.yaml --peer-ip&lt;span class="o">=&lt;/span>host.docker.internal --peer-port&lt;span class="o">=&lt;/span>&lt;span class="m">16001&lt;/span> --agent-server-port&lt;span class="o">=&lt;/span>&lt;span class="m">16002&lt;/span> --agent-registry-port&lt;span class="o">=&lt;/span>&lt;span class="m">16000&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">3&lt;/span>&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">4&lt;/span>&lt;span class="cl">&lt;span class="c1"># kraken-agent-two&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="ln">5&lt;/span>&lt;span class="cl">/usr/bin/kraken-agent --config&lt;span class="o">=&lt;/span>/etc/kraken/config/agent/development.yaml --peer-ip&lt;span class="o">=&lt;/span>host.docker.internal --peer-port&lt;span class="o">=&lt;/span>&lt;span class="m">17001&lt;/span> --agent-server-port&lt;span class="o">=&lt;/span>&lt;span class="m">17002&lt;/span> --agent-registry-port&lt;span class="o">=&lt;/span>&lt;span class="m">17000&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在容器內 testfs 的執行命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">/usr/bin/kraken-testfs --port&lt;span class="o">=&lt;/span>&lt;span class="m">14000&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在容器內 origin 的執行命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">/usr/bin/kraken-origin --config&lt;span class="o">=&lt;/span>/etc/kraken/config/origin/development.yaml --blobserver-hostname&lt;span class="o">=&lt;/span>host.docker.internal --blobserver-port&lt;span class="o">=&lt;/span>&lt;span class="m">15002&lt;/span> --peer-ip&lt;span class="o">=&lt;/span>host.docker.internal --peer-port&lt;span class="o">=&lt;/span>&lt;span class="m">15001&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在容器內 tracker 的執行命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">/usr/bin/kraken-tracker --config&lt;span class="o">=&lt;/span>/etc/kraken/config/tracker/development.yaml --port&lt;span class="o">=&lt;/span>&lt;span class="m">15003&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在容器內 build-index 的執行命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">/usr/bin/kraken-build-index --config&lt;span class="o">=&lt;/span>/etc/kraken/config/build-index/development.yaml --port&lt;span class="o">=&lt;/span>&lt;span class="m">15004&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在容器內 proxy 的執行命令&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="ln">1&lt;/span>&lt;span class="cl">/usr/bin/kraken-proxy --config&lt;span class="o">=&lt;/span>/etc/kraken/config/proxy/development.yaml --port&lt;span class="o">=&lt;/span>&lt;span class="m">15000&lt;/span> --server-port&lt;span class="o">=&lt;/span>&lt;span class="m">15005&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="相依性">相依性：&lt;/h3>
&lt;ul>
&lt;li>agent: build-index、tracker&lt;/li>
&lt;li>origin: origin、testfs&lt;/li>
&lt;li>build-index: origin、build-index、testfs&lt;/li>
&lt;li>testfs:&lt;/li>
&lt;li>tracker: origin&lt;/li>
&lt;li>proxy: origin、build-index&lt;/li>
&lt;/ul>
&lt;h3 id="安裝步驟">安裝步驟：&lt;/h3>
&lt;ol>
&lt;li>testfs：testfs是Kraken的測試檔案系統組件，主要用於測試環境中模擬儲存層。&lt;/li>
&lt;li>origin：origin是Kraken的核心儲存組件，作為整個分發系統的源頭，可以從上游 registry 拉取映像。&lt;/li>
&lt;li>build-index：build-index組件負責索引和管理映像與標籤的關係。&lt;/li>
&lt;li>proxy：proxy組件是Docker客戶端的接入點。&lt;/li>
&lt;li>tracker：tracker是P2P分發網路的協調者。&lt;/li>
&lt;li>agent：agent運行在每個需要Docker映像的主機上。&lt;/li>
&lt;/ol>
&lt;p>其中 push 需要服務 1、2、3、4
其中 pull 需要服務 1、2、3、4、5、6&lt;/p>
&lt;h3 id="整合結構">整合結構&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>優點：&lt;/p>
&lt;ol>
&lt;li>可以從其他 node 上獲取 images，減少 registry 的壓力&lt;/li>
&lt;li>拉取映像檔案效率較高&lt;/li>
&lt;li>隱匿映像檔來源&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>缺點：&lt;/p>
&lt;ol>
&lt;li>需要多建立 daemonset 服務，佔用主機資源&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;pre class="mermaid">flowchart TB
gitlab(GitLab)
gitlabci(gitlab runner)
nexus(Nexus)
harbor(Harbor)
awsecr(AWS ECR)
huaweiswr(Huawei SWR)
start -- git push --> gitlab
subgraph pn[priate network]
direction BT
gitlab --> gitlabci
gitlabci --> nexus
nexus -- cache --> gitlabci
gitlabci -- push artifacts --> harbor
end
subgraph aws[AWS]
harbor -- replications --> awsecr
awsecr -- pull images --> node1 &amp; node1' &amp; node2 &amp; node2'
subgraph kubernets cluster
node1 &lt;-- pull images --> node2
end
subgraph kubernets cluster
node1' &lt;-- pull images --> node2'
end
end
subgraph hc[Huawei Cloud]
harbor -- replications --> huaweiswr
huaweiswr -- pull images --> node1'' &amp; node1''' &amp; node2'' &amp; node2'''
subgraph kubernets cluster
node1'' &lt;-- pull images --> node2''
end
subgraph kubernets cluster
node1''' &lt;-- pull images --> node2'''
end
end&lt;/pre></description></item><item><title>比較 GitLab 和 Gitea</title><link>https://chiehting.com/posts/compare-git-repository/</link><pubDate>Wed, 06 Sep 2023 16:19:12 +0800</pubDate><guid>https://chiehting.com/posts/compare-git-repository/</guid><description>
&lt;p>本篇目標再評估兩套 source code management &lt;a href="https://about.gitlab.com/">GitLab&lt;/a> 和 &lt;a href="https://docs.gitea.com/">Gitea&lt;/a>.&lt;/p>
&lt;p>評估的切入方向：&lt;/p>
&lt;ol>
&lt;li>團隊規模： 小型團隊或大型團隊。個人定義以 10 人為分水嶺&lt;/li>
&lt;li>功能需求：CICD、監控、系統整合&lt;/li>
&lt;li>成本和預算：官方建議的主機規格差一個等級&lt;/li>
&lt;li>維護成本：運維時需要付出的人力成本，例如系統配置、系統升級&lt;/li>
&lt;li>支援文件：運維時的文件支援程度&lt;/li>
&lt;/ol>
&lt;p>以下是 GitLab 和 Gitea 的比較表格：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>特性&lt;/th>
&lt;th>GitLab&lt;/th>
&lt;th>Gitea&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>開源性&lt;/td>
&lt;td>有 CE 版本，EE 版本&lt;/td>
&lt;td>完全開源，無商業授權&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>社群和生態系統&lt;/td>
&lt;td>龐大的用戶社群，支援社群插件&lt;/td>
&lt;td>相對較小的社群，有一些插件&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>使用人數與情境&lt;/td>
&lt;td>大型團隊、適合需求複雜的功能和集成&lt;/td>
&lt;td>小型團隊、個人開發者、輕量級解決方案&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2FA&lt;/td>
&lt;td>是&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>儲存庫管理&lt;/td>
&lt;td>是&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>自動化CI/CD&lt;/td>
&lt;td>是&lt;/td>
&lt;td>部分支援，需要其他工具&lt;br>&lt;a href="https://docs.gitea.com/usage/actions/overview">gitea cicd&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>問題跟蹤&lt;/td>
&lt;td>是&lt;/td>
&lt;td>部分支援&lt;br>&lt;a href="https://docs.gitea.com/next/installation/comparison#issue-tracker">gitea issue tracker&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>合併請求&lt;/td>
&lt;td>是&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>代碼審查&lt;/td>
&lt;td>是&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>通知和集成&lt;/td>
&lt;td>多種通知方式和集成選項&lt;/td>
&lt;td>基本通知和集成&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>安全性&lt;/td>
&lt;td>強調安全性並提供相關工具&lt;/td>
&lt;td>基本的安全性&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>自托管和SaaS&lt;/td>
&lt;td>是&lt;/td>
&lt;td>是&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>學習曲線&lt;/td>
&lt;td>較高&lt;/td>
&lt;td>較低&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>資源需求&lt;/td>
&lt;td>較高&lt;/td>
&lt;td>較低&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>官方建議規格&lt;/td>
&lt;td>4 CPU/4GB RAM/100GB Disk&lt;br>&lt;a href="https://docs.gitlab.com/ee/install/requirements.html">gitlab system requirements&lt;/a>&lt;/td>
&lt;td>2 CPU/2GB RAM/50GB Disk&lt;br>&lt;a href="https://docs.gitea.com/?_highlight=cpu#system-requirements">gitea system requirements&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>專案群組管理&lt;/td>
&lt;td>專案群組，可做階層&lt;/td>
&lt;td>組織管理，無階層&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>高可用性&lt;/td>
&lt;td>是&lt;br>&lt;a href="https://about.gitlab.com/solutions/geo/">gitlab geo&lt;/a>&lt;/td>
&lt;td>部分支援，需要自定義和配置&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>備份還原機制&lt;/td>
&lt;td>是&lt;br>&lt;a href="https://docs.gitlab.com/ee/administration/backup_restore/">gitlab backup and restore&lt;/a>&lt;/td>
&lt;td>是&lt;br>&lt;a href="https://docs.gitea.com/administration/backup-and-restore?_highlight=backup">gitea backup and restore&lt;/a>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>身份認證機制&lt;/td>
&lt;td>AD、LDAP、OAuth SSO、SAML SSO&lt;/td>
&lt;td>LDAP、OAuth SSO、SAML SSO&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h4 id="references">References&lt;/h4>
&lt;ol>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/486410391">自建Git 服務器：Gitea 與Gitlab 部署踩坑經歷與對比總結&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>DevOps 面試問題</title><link>https://chiehting.com/posts/devops-exam-for-interview/</link><pubDate>Thu, 10 Aug 2023 01:01:00 +0800</pubDate><guid>https://chiehting.com/posts/devops-exam-for-interview/</guid><description>
&lt;p>為什麼要做 DevOps 面試問題？旨在於發現自己的知識盲點與提升該領域的能力。
將不定期更新題目，提升面試或被面試的能力。&lt;/p>
&lt;h4 id="面試的流程構思">面試的流程構思&lt;/h4>
&lt;p>假設筆試做題時間 30 分鐘的話, 可以抽個 6 ~ 10 題（每題作答時間約 3~5 分鐘）。 個人習慣抽一個做不完的數量，一來可以評估程度；二來可以評估如何應對做不完的考題。&lt;/p>
&lt;p>主要目的是評估能力，做與沒做完並不是重點。
當答案與預期的不符時需釐清原因，有可能有其他觀點或者是自身有盲區。&lt;/p>
&lt;h4 id="筆試">筆試&lt;/h4>
&lt;ol>
&lt;li>
&lt;p>請簡述 DevOps 的核心原則和目標是什麼？&lt;/p>
&lt;p>DevOps 是增強開發(DEV)和運營(OPS)之間的協作和整合之文化，解決傳統兩個團隊之間的隔閡和摩擦，將問題以軟體工程的方式處理實現更快速、更穩定的交付流程。其目標為：&lt;code>協作和整合&lt;/code>、&lt;code>持續整合與持續交付&lt;/code>、&lt;code>自動化&lt;/code>、&lt;code>可靠性和穩定性&lt;/code>、&lt;code>文化轉變&lt;/code>、&lt;code>迭代和持續改進&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>什麼是版本控制？版本控制在 DevOps 中有什麼作用？&lt;/p>
&lt;p>軟體工程上的版本控制，是軟體開發過程中程式碼管理和追蹤的方法。它允許團隊在多人協作的情況下，確保團隊成員能夠同時進行軟體開發，而不會干擾彼此的工作，且幫助開發人員追蹤程式碼的變更歷史。&lt;/p>
&lt;p>版本控制在 DevOps 中是重要功能之一，可以幫助開發團隊更好地管理程式碼，提高協作效率，確保代碼的品質。在自動化部署流程中，可以使用版本控制系統中的特定標籤或分支，確保在不同環境中部署一致的程式碼，使系統有更好的可靠性和穩定性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>請簡述如何管理版本控制的衝突（conflict）和合併（merge）。&lt;/p>
&lt;p>版本控制的衝突和合併是在多人協作開發的過程中常見的任務，目的是為了確保程式碼的一致性。其管理流程為：&lt;/p>
&lt;ol>
&lt;li>創建分支&lt;/li>
&lt;li>提交變更&lt;/li>
&lt;li>拉取main -&amp;gt; 解決衝突&lt;/li>
&lt;li>提交衝突變更 -&amp;gt; 進行合併&lt;/li>
&lt;/ol>
&lt;pre class="mermaid">gitGraph
commit id: "0"
commit id: "1"
branch develop
commit id: "2"
checkout main
checkout develop
commit id: "3"
commit id: "4"
checkout main
commit id: "5"
merge develop
commit id: "6"&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>請解釋容器化技術中的 uid、gid 與宿主機的關係為何？&lt;/p>
&lt;p>Linux 中使用 uid 與 gid 作為使用者和群組的唯一識別碼。在容器中進程的 uid 和 gid 通常是在創建容器映像時所定義，以實現隔離和安全性。&lt;/p>
&lt;p>容器映像中可以包含使用者和群組配置，以及對應的 uid 和 gid。當容器運行時，容器運行時環境會使用這些設定來創建容器內的使用者和群組。但如果容器中進程的 uid 和 gid 與宿主機上的 uid 和 gid 相同，可能會導致安全性問題，&lt;/p>
&lt;/li>
&lt;li>
&lt;p>請簡述 Docker 和 Kubernetes 之間的關係，以及它們分別有什麼作用？&lt;/p>
&lt;p>Docker 為容器化技術之一，用以封裝應用程序和其相關的依賴套件，創建獨立的且可移植的運行環境。Kubernetes 是一個開源的容器管理平台，用於自動化容器的部署、維護、擴展和調度。它可以管理大規模的容器集群，確保應用程序的高可用性、自動擴展和動態調整。&lt;/p>
&lt;p>Docker 與 Kubernetes 的關係為容器封裝與容器管理，確保應用程序可以在不同的運行環境中實現高可用性和彈性的部署。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>請依據您個人的經驗設計 CI/CD 流程，並請說明使用到的工具及目的？&lt;/p>
&lt;ol>
&lt;li>提交程式碼，可使用 Git、SVN&lt;/li>
&lt;li>程式碼審核，可使用 GitHub、GitLab&lt;/li>
&lt;li>執行編譯產出結果，例如 JAR、Image、static file，可使用 Docker、Podman 容器技術產生映像檔&lt;/li>
&lt;li>單元測試、整合測試，可使用 Cucumber、SoapUI&lt;/li>
&lt;li>程式漏洞掃描，可使用 SonarQube、Trivy&lt;/li>
&lt;li>產出物存儲庫，可使用 Sonatype Nexus、Harbor&lt;/li>
&lt;li>產出物簽章， 可使用 Cosign&lt;/li>
&lt;li>部署執行工具，可使用 Jenkins、Drone、Ansible&lt;/li>
&lt;li>機敏資訊管理，可使用 HashiCrop vault&lt;/li>
&lt;li>運行環境，可使用 Kubernetes&lt;/li>
&lt;/ol>
&lt;pre class="mermaid">flowchart TB
1((developer))
2[source]
3{code review}
4[build]
5[test]
6[scan]
7[artifacts repository]
8[signature]
9[deploy]
10[secrets]
11[production]
1 -->|code commit|2
subgraph SCM
2 --> 3
3 --> |pass| 2
end
3 --> |reject| 1
subgraph CI
2 --> 4
4 --> 5
5 --> 6
8
end
8 --> 7
6-->7
7 --> 9
subgraph CD
9
10 -.-> 9
end
9 --> 11&lt;/pre>
&lt;/li>
&lt;li>
&lt;p>您如何確保在不同環境中的一致性，例如開發、測試和生產環境？&lt;/p>
&lt;p>基礎建設的部分可以使用基礎設施即代碼工具，例如 Terraform、Ansible 等，使各個環境的架構相同；而服務運行的程式部分則可以透過容器化技術建立可移植的映像檔，讓映像檔有可複使用之特性，利於部署到不同環境上。當有環境架構相同性與服務程式的可移植性就可以確保各環境的狀態一致。&lt;/p>
&lt;p>當部署完成後，各環境可能會因為不同的壓力負荷導致系統產生不易發現之狀況。所以可在各環境中實施監控和追蹤，以便及時發現並解決問題，確保系統的健康運行。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>說明你在雲端平台上的經驗（AWS、Azure 或 Google Cloud），例如資源管理、自動縮放和成本優化。&lt;/p>
&lt;p>我擁有豐富的資源管理、自動縮放和成本優化經驗，透過 Infrastructure as Code 建置雲上的各個資源。並且確保在雲端平台上實施最佳的安全性，包括設定安全組、IAM 角色和權限，並遵循適用的合規性要求。&lt;/p>
&lt;p>再者使用雲平台的 Kubernetes 技術，例如 AWS 的 EKS、GCP 的 GKE 作為容器管理工具。由 Kubernets 的 Horizontal Pod Autoscaling 功能與雲平台的 Autoscaling 功能做搭配，達到依據負載量做自動調整資源，可以有效的優化成本，來依據服務負載量來做資源調度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>什麼是基礎設施即代碼（Infrastructure as Code，IaC）？有使用過哪些 IaC 工具？&lt;/p>
&lt;p>基礎設施即代碼（Infrastructure as Code，IaC）是通過程式碼的方式進行描述來管理與操作基礎設施的配置，實現自動化的基礎設施部署、管理和變更。我目前使用過的 IaC 工具有 Terraform、Terragrun 用來管理雲平台資源，並使用 Ansible 做組態配置管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>請問如何檢測 DNS Server 解析正常？&lt;/p>
&lt;p>要檢測 DNS Server 的狀況可以使用 nslookup、dig 等命令來查詢特定域名的解析結果。若要排查路由狀況可以使用 traceroute、ping、mtr 等命令來進行分析。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你有使用過哪些自動化工具，例如 Ansible、Chef 或 Puppet？請舉例說明你如何使用它們。&lt;/p>
&lt;p>我擁有豐富的 Ansible 工具使用經驗，透過 Ansible 執行自動化任務，例如：實例的組態設定與權限配置、自動部署任務、操作防火牆規則、架設 web server 等。並且搭配 Ansible AWX 介面，可以綁定角色權限做任務調度，也可做稽核審查。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如何監控和管理應用程式的運行狀況？你使用過哪些監控工具？&lt;/p>
&lt;p>基於 Kubernetes 架構上，可以透過探針 (Probes) 來確認應用程式的運行狀態。為了可以保存週期性的資料，使用了 Prometheus 用於多維度數據收集和警報，並採用可視化監控數據工具 Grafana 做數據整理與分析，將結果呈現在儀表板上，進而達到監控和管理應用程式的運行狀況。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你在監控和日誌分析方面使用過哪些工具？如何確保及時發現問題並進行故障排除？&lt;/p>
&lt;p>基於 Kubernetes 架構上，建置了 Fluent Bit 作為日誌搜集與過濾之工具，並將其結果儲存在 AWS CloudWatch 上的 Log Stream 中，最後使用數據可視化和監控工具 Grafana 創建圖表和儀表板。&lt;/p>
&lt;p>基於上述的日誌系統架構，可以設定告警規則、實時監控、日誌分析和查找等，綜合使用這些方法，可以在及早發現問題並快速進行故障排除方面實現更好的效果。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>你在持續備份和數據恢復方面的經驗是什麼？請描述你的方法和工具。&lt;/p>
&lt;p>收先需確認備份資的對象，假設以 AWS RDS 為例子，RDS 服務有提供多種備份機制，我過往的經驗是採用快照備份，快照是一個靈活的備份方式，它可以保存 RDS 實例的當前狀態，包括數據庫、日誌和配置等。&lt;/p>
&lt;p>RDS 快照保存為 1 天 1 次，所以還是有可能造成 24 小時內的資料遺失。為了解決資料遺失區間過大，所以也導入了增量備份的策略。我採用的增量備份策略是備份一定時間內的 Binary Logs，並設定自動化備份流程執行定期備份，使資料遺失的區間減少。&lt;/p>
&lt;p>當 RDS 毀損時，即可以使用 &amp;quot;快照&amp;quot; 與 &amp;quot;Binary Logs&amp;quot; 做數據恢復，盡可能減少資料遺失過多導致損失過大的風險。資料毀損已經是很嚴重的災情，為了避免到這一步，通常也會把系統設計為高可用性架構。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>請簡述 Container 的生命週期 (基於 OCI 標準)？&lt;/p>
&lt;p>基於 OCI (Open Container Initiative) 標準，容器的生命週期可以簡述如下:&lt;/p>
&lt;ol>
&lt;li>Image 準備階段：這個階段包括 Dockerfile 或其他容器設定檔的編寫，來定義映像檔，然後使用 Docker 或其他容器引擎來建立 Image。&lt;/li>
&lt;li>Container 建立階段：這個階段為運行容器引擎命令，並指示引擎使用指定的 Image 和配置來啟動容器。&lt;/li>
&lt;li>Container 執行階段： 在此階段，容器內運行的應用程式開始處於運行狀態，並根據設定執行所需的工作。&lt;/li>
&lt;li>Container 停止階段： 當應用程式完成其工作，或者其他原因來停止容器。停止後，容器不再執行應用程式並且可以從系統中移除。&lt;/li>
&lt;li>Container 刪除階段： 容器停止後，可以從系統中刪除容器實例。刪除容器將釋放系統資源，並清理容器的臨時數據等。&lt;/li>
&lt;/ol>
&lt;pre class="mermaid">flowchart LR
1[Create Image]
2[Container registry]
3[Container creation]
4[Container execution]
5[Container stop]
6[Container Deletion]
image-spec --> distribution-spec
distribution-spec --> runtime-spec
subgraph image-spec
1
end
subgraph distribution-spec
2
end
subgraph runtime-spec
3 --> 4
4 --> 5
5 --> 6
end&lt;/pre>
&lt;/li>
&lt;/ol>
&lt;h4 id="面談">面談&lt;/h4>
&lt;ol>
&lt;li>如何處理服務的擴展和負載均衡？&lt;/li>
&lt;li>如何管理機密資料和敏感設定，例如密碼和 API 金鑰？&lt;/li>
&lt;li>你如何確保應用程式和基礎設施的安全性？有哪些安全實踐？&lt;/li>
&lt;li>如何優化應用程式和基礎設施的性能？&lt;/li>
&lt;li>你有使用過 Configuration Management 工具嗎？請舉例說明。&lt;/li>
&lt;li>什麼是微服務架構，你認為它有哪些優勢和挑戰？&lt;/li>
&lt;li>解釋 CI/CD 的概念以及它如何有助於軟體交付流程。&lt;/li>
&lt;li>什麼是 Kubernetes？請說明它的主要功能和優點。&lt;/li>
&lt;li>談談你如何確保基礎設施的高可用性和彈性。&lt;/li>
&lt;li>如何在高可用性環境中設計和部署應用程式？依據你過往的經驗說明。&lt;/li>
&lt;li>請描述一個你曾經處理過的緊急系統故障的經驗，以及你是如何排除。&lt;/li>
&lt;li>談談容錯和災難恢復（Disaster Recovery）的策略，以及你如何確保系統的高可用性和故障容忍性。&lt;/li>
&lt;li>解釋軟體部署的藍綠部署（Blue-Green Deployment）和金絲雀部署（Canary Deployment），以及它們的優點和用途。&lt;/li>
&lt;li>請談談你如何監控和管理日誌（log），以確保系統的可追蹤性和故障排查。&lt;/li>
&lt;li>最近你學習或採用的新技術、工具或實踐是什麼？請講述你學習和應用它們的經驗。&lt;/li>
&lt;li>在你的過去經驗中，你覺得自己在哪些方面最具有優勢，可以為團隊帶來最大的價值？&lt;/li>
&lt;/ol>
&lt;h4 id="進階問題">進階問題&lt;/h4>
&lt;ol>
&lt;li>請解釋一下軟件定義網絡（SDN）在 DevOps 中的應用。&lt;/li>
&lt;li>你如何處理系統中的數據安全和隱私問題？&lt;/li>
&lt;li>如何進行流量規劃，確保系統在負載高峰期仍然可用？&lt;/li>
&lt;li>解釋一下無服務區（Dark Launch）的概念，以及在實際應用中的優勢。&lt;/li>
&lt;li>你曾經遇到過一個數據庫性能下降的情況，你會如何診斷和解決這個問題？&lt;/li>
&lt;li>如果你需要設計一個分佈式系統的負載均衡策略，你會考慮哪些因素？&lt;/li>
&lt;li>你如何處理分佈式系統中的一致性和異常情況？&lt;/li>
&lt;li>你如何測試和確保新的代碼變更不會影響現有系統的穩定性？&lt;/li>
&lt;li>如果系統的壓力測試顯示出性能問題，你會如何分析並解決這些問題？&lt;/li>
&lt;li>請描述你如何設計和實現自動化的故障回滾（Rollback）策略。&lt;/li>
&lt;/ol></description></item></channel></rss>